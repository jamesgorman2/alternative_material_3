import 'package:flutter/animation.dart';

import 'colors.dart';

/// Linearly interpolate between two integers.
///
/// Same as [lerpDouble] but specialized for non-null `int` type.
double _lerpInt(int a, int b, double t) {
  return a + (b - a) * t;
}

/// Same as [num.clamp] but specialized for non-null [int].
int _clampInt(int value, int min, int max) {
  assert(min <= max);
  if (value < min) {
    return min;
  } else if (value > max) {
    return max;
  } else {
    return value;
  }
}

/// Extensions on Color.
extension ColorExtension on Color {
  /// True if the color is transparent, regardless of color.
  bool get isTransparent => alpha == 0;

  /// Return a null value if [c] is [Colors.transparent].
  Color? get nullTransparency => ColorExtensions.nullTransparency(this);

  /// Return a null value if [c] is transparent.
  Color? get nullAnyTransparency => ColorExtensions.nullAnyTransparency(this);
}

/// Utility functions on [Color]
class ColorExtensions {
  static Color _scaleAlpha(Color a, double factor) {
    return a.withAlpha((a.alpha * factor).round().clamp(0, 255));
  }

  /// Linearly interpolate between two colors with null values being
  /// treated as transparent.
  ///
  /// This is intended to be fast but as a result may be ugly. Consider
  /// [HSVColor] or writing custom logic for interpolating colors.
  ///
  /// If either color is null, this function linearly interpolates from a
  /// transparent instance of the other color. This is usually preferable to
  /// interpolating from [material.Colors.transparent] (`const
  /// Color(0x00000000)`), which is specifically transparent _black_.
  ///
  /// The `t` argument represents position on the timeline, with 0.0 meaning
  /// that the interpolation has not started, returning `a` (or something
  /// equivalent to `a`), 1.0 meaning that the interpolation has finished,
  /// returning `b` (or something equivalent to `b`), and values in between
  /// meaning that the interpolation is at the relevant point on the timeline
  /// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  /// 1.0, so negative values and values greater than 1.0 are valid (and can
  /// easily be generated by curves such as [Curves.elasticInOut]). Each channel
  /// will be clamped to the range 0 to 255.
  ///
  /// Values for `t` are usually obtained from an [Animation<double>], such as
  /// an [AnimationController].
  static Color lerpNonNull(Color? a, Color? b, double t) {
    if (b == null) {
      if (a == null) {
        return Colors.transparent;
      } else {
        return _scaleAlpha(a, 1.0 - t);
      }
    } else {
      if (a == null) {
        return _scaleAlpha(b, t);
      } else {
        return Color.fromARGB(
          _clampInt(_lerpInt(a.alpha, b.alpha, t).toInt(), 0, 255),
          _clampInt(_lerpInt(a.red, b.red, t).toInt(), 0, 255),
          _clampInt(_lerpInt(a.green, b.green, t).toInt(), 0, 255),
          _clampInt(_lerpInt(a.blue, b.blue, t).toInt(), 0, 255),
        );
      }
    }
  }

  /// Linearly interpolate between two colors with null values being
  /// treated as transparent.
  ///
  /// This is intended to be fast but as a result may be ugly. Consider
  /// [HSVColor] or writing custom logic for interpolating colors.
  ///
  /// If either color is null or identical to [material.Colors.transparent],
  /// this function linearly interpolates from a
  /// transparent instance of the other color.
  ///
  /// The `t` argument represents position on the timeline, with 0.0 meaning
  /// that the interpolation has not started, returning `a` (or something
  /// equivalent to `a`), 1.0 meaning that the interpolation has finished,
  /// returning `b` (or something equivalent to `b`), and values in between
  /// meaning that the interpolation is at the relevant point on the timeline
  /// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  /// 1.0, so negative values and values greater than 1.0 are valid (and can
  /// easily be generated by curves such as [Curves.elasticInOut]). Each channel
  /// will be clamped to the range 0 to 255.
  ///
  /// Values for `t` are usually obtained from an [Animation<double>], such as
  /// an [AnimationController].
  static Color lerpTransparency(Color? a, Color? b, double t) {
    if (b == null || identical(b, Colors.transparent)) {
      if (a == null || identical(a, Colors.transparent)) {
        return Colors.transparent;
      } else {
        return _scaleAlpha(a, 1.0 - t);
      }
    } else {
      if (a == null || identical(a, Colors.transparent)) {
        return _scaleAlpha(b, t);
      } else {
        return Color.fromARGB(
          _clampInt(_lerpInt(a.alpha, b.alpha, t).toInt(), 0, 255),
          _clampInt(_lerpInt(a.red, b.red, t).toInt(), 0, 255),
          _clampInt(_lerpInt(a.green, b.green, t).toInt(), 0, 255),
          _clampInt(_lerpInt(a.blue, b.blue, t).toInt(), 0, 255),
        );
      }
    }
  }

  /// Return a null value if [c] is [Colors.transparent].
  static Color? nullTransparency(Color? c) {
    if (identical(c, Colors.transparent)) {
      return null;
    }
    return c;
  }

  /// Return [Colors.transparent] if c is null.
  static Color nonNullTransparency(Color? c) {
    return c ?? Colors.transparent;
  }

  /// Return a null value if [c] is transparent.
  static Color? nullAnyTransparency(Color? c) {
    if (c?.isTransparent ?? false) {
      return null;
    }
    return c;
  }
}

/// An interpolation between two colors, returning transparent for
/// null values.
///
/// This class specializes the interpolation of [Tween<Color>] to use
/// [ColorExtensions.lerpNonNull].
///
/// The values can be null, representing no color (which is distinct to
/// transparent black, as represented by [Colors.transparent]).
///
/// See [Tween] for a discussion on how to use interpolation objects.
class ColorTweenNonNull extends ColorTween {
  /// Creates a [Color] tween.
  ///
  /// The [begin] and [end] properties may be null; the null value
  /// is treated as transparent.
  ///
  /// We recommend that you do not pass [Colors.transparent] as [begin]
  /// or [end] if you want the effect of fading in or out of transparent.
  /// Instead prefer null. [Colors.transparent] refers to black transparent and
  /// thus will fade out of or into black which is likely unwanted.
  ColorTweenNonNull({super.begin, super.end});

  /// Returns the value this variable has at the given animation clock value.
  @override
  Color lerp(double t) => ColorExtensions.lerpNonNull(begin, end, t);

  @override
  Color transform(double t) {
    return lerp(t);
  }
}

/// An interpolation between two colors, returning transparent for
/// null values.
///
/// This class specializes the interpolation of [Tween<Color>] to use
/// [ColorExtensions.lerpNonNull].
///
/// The values can be null, representing no color (which is distinct to
/// transparent black, as represented by [Colors.transparent]). This will
/// interpret any [begin] or [end] value that is [identical] to
/// [Colors.transparent] as null.
///
/// See [Tween] for a discussion on how to use interpolation objects.
class ColorTweenTransparency extends ColorTween {
  /// Creates a [Color] tween.
  ///
  /// The [begin] and [end] properties may be null; the null value
  /// is treated as transparent.This will
  /// interpret any [begin] or [end] value that is [identical] to
  /// [Colors.transparent] as null.
  ColorTweenTransparency({super.begin, super.end});

  /// Returns the value this variable has at the given animation clock value.
  @override
  Color lerp(double t) => ColorExtensions.lerpTransparency(begin, end, t);

  @override
  Color transform(double t) {
    return lerp(t);
  }
}
